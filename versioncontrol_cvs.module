<?php
// $Id$
/**
 * @file
 * CVS backend for Version Control API - Provides CVS commit information and
 * account management as a pluggable backend.
 *
 * Copyright 2007 by Jakob Petsovits ("jpetso", http://drupal.org/user/56020)
 */

// Update methods.
define('VERSIONCONTROL_CVS_UPDATE_CRON', 0);
define('VERSIONCONTROL_CVS_UPDATE_XCVS', 1);

// The admin pages.
include_once(drupal_get_path('module', 'versioncontrol_cvs') .'/versioncontrol_cvs.admin.inc');

/**
 * Implementation of hook_versioncontrol_backends().
 *
 * @return
 *   A structured array containing information about this known backends.
 *   Array key is the unique string identifier of the version control system.
 *   The corresponding array values are again structured arrays and consist
 *   of elements with the following keys:
 *
 *   'name': The user-visible name of the VCS.
 *   'description': A short description of the backend, if possible not longer
 *                  than one or two sentences.
 *   'capabilities': An array listing optional capabilities, in addition to the
 *                   required functionality like retrieval of detailed
 *                   commit information. Array values can be an arbitrary
 *                   combination of VERSIONCONTROL_CAPABILITY_* values. If no
 *                   additional capabilities are supported by the backend,
 *                   this array will be empty.
 *   'autoadd': An array listing which tables should be managed by
 *              Version Control API instead of doing it manually in
 *              the backend. Array values can be an arbitrary combination of
 *              VERSIONCONTROL_AUTOADD_* values. If no array additions
 *              should be automatically managed, this array will be empty.
 */
function versioncontrol_cvs_versioncontrol_backends() {
  return array(
    // The array key is up to 8 characters long, and used as unique identifier
    // for this VCS, in functions, URLs and in the database.
    'cvs' => array(
      // The user-visible name of the VCS.
      'name' => 'CVS',

      // A short description of the VCS, if possible not longer than one or two sentences.
      'description' => t('CVS (Concurrent Versions System) is a slightly older code management system that supports file revisions, tags and branches, but lacks atomic commits, advanced merge functionality and support for renaming items.'),

      // A list of optional capabilities, in addition to the required retrieval
      // of detailed commit information.
      'capabilities' => array(),

      // An array listing which tables should be managed by Version Control API
      // instead of doing it manually in the backend.
      'flags' => array(
        // versioncontrol_insert_repository() will automatically insert
        // array elements from $repository['cvs_specific'] into
        // {versioncontrol_cvs_repositories} and versioncontrol_get_repositories()
        // will automatically fetch it from there.
        VERSIONCONTROL_FLAG_AUTOADD_REPOSITORIES,
        // versioncontrol_insert_commit() will automatically insert
        // array elements from $commit['cvs_specific'] into
        // {versioncontrol_cvs_commits} and versioncontrol_get_commits()
        // will automatically fetch it from there.
        VERSIONCONTROL_FLAG_AUTOADD_COMMITS,
      ),
    ),
  );
}


/**
 * Implementation of [versioncontrol_backend]_get_commit_actions():
 * Retrieve detailed information about what happened in a single commit.
 *
 * @param $commit
 *   The commit whose actions should be retrieved.
 *
 * @return
 *   A structured array containing the exact details of what happened to
 *   each item in this commit. Array keys are the current/new paths, also for
 *   VERSIONCONTROL_ACTION_DELETED actions even if the file actually doesn't
 *   exist anymore. The corresponding array values are again structured arrays
 *   and consist of elements with the following keys:
 *
 *   'action': Specifies how the item was modified.
 *             One of the predefined VERSIONCONTROL_ACTION_* values.
 *   'modified': Boolean value, specifies if a file was modified in addition
 *               to the other action in the 'action' element of the array.
 *               Only exists for the VERSIONCONTROL_ACTION_MOVED
 *               and VERSIONCONTROL_ACTION_COPIED actions.
 *   'current item': The updated state of the modified item. Exists for all
 *                   actions except VERSIONCONTROL_ACTION_DELETED.
 *   'source items': An array with the previous state(s) of the modified item.
 *                   Path and branch will always be the same as in the current
 *                   item except for the VERSIONCONTROL_ACTION_MOVED,
 *                   VERSIONCONTROL_ACTION_COPIED and
 *                   VERSIONCONTROL_ACTION_MERGED actions.
 *                   Exists for all actions except VERSIONCONTROL_ACTION_ADDED.
 *
 *   Item values are structured arrays and consist of elements
 *   with the following keys:
 *
 *   'type': Specifies the item type, which is either
 *           VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   'path': The path of the item at the specific revision.
 *   'revision': The (file-level) revision when the item was changed.
 *               If there is no such revision (which may be the case for
 *               directory items) then the 'revision' element is NULL.
 *   '[xxx]_specific': May be set by the backend to remember additional
 *                     item info. ("[xxx]" is the unique string identifier
 *                     of the respective version control system.)
 */
function versioncontrol_cvs_get_commit_actions($commit) {
  $actions = array();
  $result = db_query("SELECT * FROM {versioncontrol_cvs_item_revisions}
                      WHERE commit_id = '%d'", $commit['commit_id']);

  while ($item_revision = db_fetch_object($result)) {
    $action = array(
      'type' => $item_revision->action,
    );

    if ($item_revision->action != VERSIONCONTROL_ACTION_DELETED) {
      $action['current item'] = array(
        'type' => $item_revision->type,
        'path' => $item_revision->path,
        'revision' => $item_revision->revision,
        'cvs_specific' => array(
          'selected branch' => $commit['cvs_specific']['branch_id'],
          'selected date' => $commit['date'],
        ),
      );
    }
    if ($item_revision->action != VERSIONCONTROL_ACTION_ADDED) {
      $action['source items'] = array(array(
        'type' => $item_revision->type,
        'path' => $item_revision->path,
        'revision' => $item_revision->source_revision,
        'cvs_specific' => array(
          'selected branch' => $commit['cvs_specific']['branch_id'],
          'selected date' => $commit['date'],
        ),
      ));
    }

    $actions[$item_revision->path] = $action;
  }

  return $actions;
}

/**
 * Implementation of [versioncontrol_backend]_get_commit_directory_item():
 * Retrieve the item of the deepest-level directory in the repository that is
 * common to all the changed items in a commit. In other words, this function
 * gets you the item for $commit['directory'].
 *
 * @param $commit
 *   The commit whose deepest-level changed directory should be retrieved.
 *
 * @return
 *   The requested directory item. Item values are structured arrays and
 *   consist of elements with the following keys:
 *
 *   'type': Specifies the item type, which in this case can only be
 *           VERSIONCONTROL_ITEM_DIRECTORY.
 *   'path': The path of the directory at the time of the commit.
 *   'revision': The (file-level) revision when the item was last changed.
 *               If there is no such revision (which may be the case for
 *               directory items) then the 'revision' element is NULL.
 *   '[xxx]_specific': May be set by the backend to remember additional
 *                     item info. ("[xxx]" is the unique string identifier
 *                     of the respective version control system.)
 */
function versioncontrol_cvs_get_commit_directory_item($commit) {
  return array(
    'type' => VERSIONCONTROL_ITEM_DIRECTORY,
    'path' => $commit['directory'],
    'revision' => NULL,
    'cvs_specific' => array(
      'selected branch' => $commit['cvs_specific']['branch_id'],
      'selected date' => $commit['date'],
    ),
  );
}

/**
 * Implementation of [versioncontrol_backend]_get_commit_branches():
 * Retrieve the branches that have been affected by the given commit.
 *
 * @return
 *   An array of strings that identify a branch in the respective repository,
 *   or an empty array if no branches were affected at all. (For CVS, there
 *   should always be a exactly one branch in the resulting array.)
 */
function versioncontrol_cvs_get_commit_branches($commit) {
  if (!isset($commit['cvs_specific']['branch_id'])) {
    return array();
  }
  $branches_by_repository = _versioncontrol_cvs_get_branches(array(
    'branch_ids' => array($commit['cvs_specific']['branch_id']),
  ));
  foreach ($branches_by_repository as $repo_id => $branches) {
    // we asked for one branch in one repository, so there's only one result
    foreach ($branches as $id => $name) {
      return array($name);
    }
  }
  return array(); // should only happen in case of database inconsistencies
}

/**
 * Implementation of [versioncontrol_backend]_get_current_item_branch():
 * Retrieve the current branch that this item is in. If this item was part of
 * the result of versioncontrol_get_commit_actions(), this will probably be
 * the branch that this item was committed to. If no specific branch is known
 * or applicable for this item, NULL is returned. The main branch ('HEAD'
 * for CVS) is also a valid branch and should be expected as return value.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose current branch should be retrieved.
 *
 * @return
 *   A string containing the current item branch, or NULL if no branch
 *   is known or applicable.
 */
function versioncontrol_cvs_get_current_item_branch($repository, $item) {
  if (!isset($item['cvs_specific']['selected branch'])) {
    return NULL;
  }

  $branches_by_repository = _versioncontrol_cvs_get_branches(array(
    'branch_ids' => array($item['cvs_specific']['selected branch']),
  ));
  foreach ($branches_by_repository as $repo_id => $branches) {
    // we asked for one branch in one repository, so there's one result at maximum
    foreach ($branches as $id => $name) {
      return $name;
    }
  }
  return NULL;
}

/**
 * Implementation of [versioncontrol_backend]_get_current_item_branch():
 * Retrieve the current branch that this item is in. If this item was part of
 * the result of versioncontrol_get_commit_actions(), this will probably be
 * the branch that this item was committed to. If no specific branch is known
 * or applicable for this item, NULL is returned. The main branch ('HEAD'
 * for CVS) is also a valid branch and should be expected as return value.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose current branch should be retrieved.
 *
 * @return
 *   A string containing the current item branch, or NULL if no branch
 *   is known or applicable.
 */
function versioncontrol_cvs_get_current_item_tag($repository, $item) {
  if (!isset($item['cvs_specific']['selected tag'])) {
    return NULL;
  }

  return NULL;
  /* TODO: implement
  $tags_by_repository = _versioncontrol_cvs_get_tags(array(
    'tag_ids' => array($item['cvs_specific']['selected tag']),
  ));
  foreach ($tags_by_repository as $repo_id => $tags) {
    // we asked for one tag in one repository, so there's one result at maximum
    foreach ($tags as $id => $name) {
      return $name;
    }
  }
  return NULL;
  */
}


/**
 * Implementation of [versioncontrol_backend]_commit():
 * Manage (insert or delete) additional commit data in the database.
 *
 * @param $op
 *   Either 'insert' when the commit is in the process of being created,
 *   or 'delete' if it will be deleted after this function has been called.
 * @param $commit
 *   A single commit array, like the ones returned
 *   by versioncontrol_get_commits().
 * @param $commit_actions
 *   A structured array containing the exact details of what happened to
 *   each item in this commit. The structure of this array is the same as
 *   the return value of versioncontrol_get_commit_actions().
 */
function versioncontrol_cvs_commit($op, $commit, $commit_actions) {
  switch ($op) {
    case 'insert':
      foreach ($commit_actions as $path => $action) {
        $revision = NULL;
        $source_revision = NULL;

        // If available, get item type and revision from the contained items.
        if (isset($action['current item'])) {
          $type = $action['current item']['type'];
          $revision = $action['current item']['revision'];
        }
        if (isset($action['source items'])) {
          $type = $action['source items'][0]['type']; // only one source item for CVS
          $source_revision = $action['source items'][0]['revision'];
        }

        db_query(
          "INSERT INTO {versioncontrol_cvs_item_revisions}
          (commit_id, type, path, revision, action, lines_added, lines_removed, source_revision)
          VALUES ('%d', '%d', '%s', '%s', '%d', '%d', '%d', '%s')",
          $commit['commit_id'], $type, $path, $revision, $action['action'],
          $action['cvs_specific']['lines_added'], $action['cvs_specific']['lines_removed'],
          $source_revision
        );
      }
      break;

    case 'delete':
      db_query("DELETE FROM {versioncontrol_cvs_item_revisions}
                WHERE commit_id = '%d'", $commit['commit_id']);
      break;
  }
}

/**
 * Implementation of [versioncontrol_backend]_account():
 * Manage (insert, update or delete) additional CVS user account data
 * in the database.
 *
 * @param $op
 *   Either 'insert' when the account is in the process of being created,
 *   or 'update' when username or VCS specific data change,
 *   or 'delete' if it will be deleted after this function has been called.
 * @param $uid
 *   The Drupal user id corresponding to the VCS account.
 * @param $username
 *   The VCS specific username (a string).
 * @param $repository
 *   The repository where the user has its VCS account.
 * @param $cvs_specific
 *   An array of CVS specific additional author information.
 */
function versioncontrol_cvs_account($op, $uid, $username, $repository, $cvs_specific = NULL) {
  switch ($op) {
    case 'insert':
      if (!is_array($cvs_specific) || !isset($cvs_specific['password'])) {
        drupal_set_message(t('Error: no CVS password given on account creation!'), 'error');
        return;
      }
      db_query("INSERT INTO {versioncontrol_cvs_accounts}
                (uid, repo_id, password)
                VALUES ('%d', '%d', '%s')",
                $uid, $repository['repo_id'], $cvs_specific['password']);
      break;

    case 'update':
      if (!is_array($cvs_specific) || !isset($cvs_specific['password'])) {
        return; // the user didn't update the password in the process.
      }
      db_query("UPDATE {versioncontrol_cvs_accounts}
                SET password = '%s'
                WHERE uid = '%d' AND repo_id = '%d'",
                $cvs_specific['password'], $uid, $repository['repo_id']);

      if (!user_access('administer version control systems')) {
        // Admins get "The account has been updated successfully" anyways.
        drupal_set_message(t('The CVS password has been updated successfully.'));
      }
      break;

    case 'delete':
      db_query("DELETE FROM {versioncontrol_cvs_accounts}
                WHERE uid = '%d' AND repo_id = '%d'",
                $uid, $repository['repo_id']);
      break;
  }
}

/**
 * Insert a branch into the {versioncontrol_cvs_branches} table.
 * No checking is done whether the branch already exists or not.
 *
 * @return
 *   The branch id of the newly inserted branch entry.
 */
function _versioncontrol_cvs_insert_branch($repo_id, $name) {
  $branch_id = db_next_id('{versioncontrol_cvs_branches}_branch_id');
  db_query("INSERT INTO {versioncontrol_cvs_branches} (branch_id, repo_id, name)
            VALUES ('%d', '%d', '%s')", $branch_id, $repo_id, $name);
  return $branch_id;
}

/**
 * Retrieve one or more entries from the {versioncontrol_cvs_branches} table.
 *
 * @param $constraints
 *   An optional array of constraints. Possible array elements are:
 *
 *   'branch_ids': An array of branch ids.
 *   'repo_ids': An array of repository ids.
 *   'names': An array of branch names.
 *
 * @return
 *   A mapping of branch ids to their respective names, like
 *   array($repo_id => array($branch_id => $branch_name, ...), ...).
 */
function _versioncontrol_cvs_get_branches($constraints = array()) {
  static $branch_cache_by_id = array();
  $branches = array();

  // Use the cache for branch-id-only queries.
  if (isset($constraints['branch_ids']) && count($constraints) == 1) {
    foreach ($constraints['branch_ids'] as $key => $branch_id) {
      if (isset($branch_cache_by_id[$branch_id])) {
        $branch = $branch_cache_by_id[$branch_id];
        $branches[$branch['repo_id']][$branch['branch_id']] = $branch['name'];
        unset($constraints['branch_ids'][$key]);
      }
    }
    if (empty($constraints['branch_ids'])) {
      return $branches;
    }
  }

  $and_constraints = array();
  $params = array();

  if (isset($constraints['branch_ids'])) {
    $or_constraints = array();
    foreach ($constraints['branch_ids'] as $branch_id) {
      $or_constraints[] = "branch_id = '%d'";
      $params[] = $branch_id;
    }
    $and_constraints[] = '('. implode(" OR ", $or_constraints) .')';
  }

  if (isset($constraints['repo_ids'])) {
    $or_constraints = array();
    foreach ($constraints['repo_ids'] as $repo_id) {
      $or_constraints[] = "repo_id = '%d'";
      $params[] = $repo_id;
    }
    $and_constraints[] = '('. implode(" OR ", $or_constraints) .')';
  }

  if (isset($constraints['names'])) {
    $or_constraints = array();
    foreach ($constraints['names'] as $name) {
      $or_constraints[] = "name = '%s'";
      $params[] = $name;
    }
    $and_constraints[] = '('. implode(' OR ', $or_constraints) .')';
  }

  // All constraints have been gathered, execute the query now.
  if (empty($and_constraints)) {
    $result = db_query('SELECT * FROM {versioncontrol_cvs_branches}');
  }
  else {
    $result = db_query('SELECT * FROM {versioncontrol_cvs_branches}
                        WHERE '. implode(' AND ', $and_constraints), $params);
  }

  // Assemble the return value.
  while ($branch = db_fetch_object($result)) {
    if (!isset($branches[$branch->repo_id])) {
      $branches[$branch->repo_id] = array();
    }
    $branches[$branch->repo_id][$branch->branch_id] = $branch->name;
    $branch_cache_by_id[$branch->branch_id] = array(
      'branch_id' => $branch->branch_id,
      'repo_id'   => $branch->repo_id,
      'name'      => $branch->name,
    );
  }
  return $branches;
}
